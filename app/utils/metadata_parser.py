"""
Metadata parser for PDF-extracted image filenames

Extracts page numbers, bounding boxes, and extraction mode from filenames
generated by the pdf-extractor Docker container.
"""
import re
import logging
from typing import Dict, Optional, Tuple, Any
import exiftool

logger = logging.getLogger(__name__)


def parse_pdf_extraction_filename(filename: str) -> Dict[str, Optional[any]]:
    """
    Parse PDF extraction metadata from image filename.
    
    Supports two formats:
    
    Normal mode (with bounding box):
        Format: p-{page}-x0-{x0}-y0-{y0}-x1-{x1}-y1-{y1}-{id}.png
        Example: p-4-x0-40.000-y0-59.280-x1-553.600-y1-492.000-1.png
        Extracted: {
            'page_number': 4,
            'bbox': {'x0': 40.0, 'y0': 59.28, 'x1': 553.6, 'y1': 492.0},
            'extraction_mode': 'normal',
            'original_filename': 'p-4-x0-40.000-y0-59.280-x1-553.600-y1-492.000-1.png'
        }
    
    Safe mode (without bounding box):
        Format: p-{page}-{id}.png
        Example: p-4-1.png
        Extracted: {
            'page_number': 4,
            'bbox': None,
            'extraction_mode': 'safe',
            'original_filename': 'p-4-1.png'
        }
    
    Args:
        filename: Filename to parse
        
    Returns:
        Dict with keys: page_number, bbox, extraction_mode, original_filename
        All fields present; None for missing data
        
    Examples:
        >>> parse_pdf_extraction_filename('p-4-x0-40.000-y0-59.280-x1-553.600-y1-492.000-1.png')
        {
            'page_number': 4,
            'bbox': {'x0': 40.0, 'y0': 59.28, 'x1': 553.6, 'y1': 492.0},
            'extraction_mode': 'normal',
            'original_filename': 'p-4-x0-40.000-y0-59.280-x1-553.600-y1-492.000-1.png'
        }
        
        >>> parse_pdf_extraction_filename('p-4-1.png')
        {
            'page_number': 4,
            'bbox': None,
            'extraction_mode': 'safe',
            'original_filename': 'p-4-1.png'
        }
    """
    result = {
        'page_number': None,
        'bbox': None,
        'extraction_mode': None,
        'original_filename': filename
    }
    
    # Remove file extension
    name_without_ext = filename.rsplit('.', 1)[0]
    
    # Pattern 1: Normal mode with bbox
    # p-{page}-x0-{x0}-y0-{y0}-x1-{x1}-y1-{y1}-{id}
    normal_pattern = r'^p-(\d+)-x0-([\d.]+)-y0-([\d.]+)-x1-([\d.]+)-y1-([\d.]+)-(\d+)$'
    match = re.match(normal_pattern, name_without_ext)
    
    if match:
        try:
            result['page_number'] = int(match.group(1))
            result['bbox'] = {
                'x0': float(match.group(2)),
                'y0': float(match.group(3)),
                'x1': float(match.group(4)),
                'y1': float(match.group(5))
            }
            result['extraction_mode'] = 'normal'
            logger.debug(f"Parsed normal mode: {filename} → page {result['page_number']}, bbox {result['bbox']}")
            return result
        except (ValueError, IndexError) as e:
            logger.warning(f"Failed to parse normal mode filename {filename}: {str(e)}")
    
    # Pattern 2: Safe mode without bbox
    # p-{page}-{id}
    safe_pattern = r'^p-(\d+)-(\d+)$'
    match = re.match(safe_pattern, name_without_ext)
    
    if match:
        try:
            result['page_number'] = int(match.group(1))
            result['bbox'] = None
            result['extraction_mode'] = 'safe'
            logger.debug(f"Parsed safe mode: {filename} → page {result['page_number']}")
            return result
        except (ValueError, IndexError) as e:
            logger.warning(f"Failed to parse safe mode filename {filename}: {str(e)}")
    
    # Could not parse as PDF extraction filename
    logger.debug(f"Filename does not match PDF extraction patterns: {filename}")
    return result


def is_pdf_extraction_filename(filename: str) -> bool:
    """
    Check if a filename matches PDF extraction patterns.
    
    Args:
        filename: Filename to check
        
    Returns:
        True if filename matches normal or safe mode pattern, False otherwise
    """
    name_without_ext = filename.rsplit('.', 1)[0]
    
    # Check both patterns
    normal_pattern = r'^p-(\d+)-x0-([\d.]+)-y0-([\d.]+)-x1-([\d.]+)-y1-([\d.]+)-(\d+)$'
    safe_pattern = r'^p-(\d+)-(\d+)$'
    
    return bool(re.match(normal_pattern, name_without_ext) or re.match(safe_pattern, name_without_ext))

def extract_exif_metadata(image_path: str) -> Dict[str, Any]:
    """
    Extract metadata from an image file using ExifTool.
    
    Args:
        image_path: Path to the image file
        
    Returns:
        Dictionary containing metadata (EXIF, XMP, IPTC, etc.)


    Performance Warning:
    This function creates a new instance of ExifTool (starts a subprocess) every time you call it.
        If you process 1 photo: It works perfectly.
        If you process 1,000 photos in a loop: It will be extremely slow (opening and closing the application 1,000 times).
        If you use this in a loop, you should refactor to pass a list of files, or keep the helper open outside the function.
    """
    try:
        # ExifToolHelper manages the background process automatically
        with exiftool.ExifToolHelper() as et:
            # get_metadata always returns a list of dicts (one per file)
            metadata_list = et.get_metadata(image_path)
            
            if not metadata_list:
                return {"exif_status": "No metadata found."}
            
            # Return the dictionary for the single file we processed
            return metadata_list[0]

    except exiftool.exceptions.ExifToolExecuteError as e:
        logger.warning(f"ExifTool execution failed for {image_path}: {e}")
    except Exception as e:
        logger.warning(f"Unexpected error extracting metadata from {image_path}: {e}")
    
    return {"exif_status": "No EXIF metadata found or could not be read."}
